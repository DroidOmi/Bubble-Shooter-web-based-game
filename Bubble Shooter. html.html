<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bubble Shooter Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
            background-size: 400% 400%;
            animation: gradientShift 15s ease infinite;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            overflow-x: hidden;
        }

        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .game-header {
            color: white;
            text-align: center;
            margin-bottom: 20px;
        }

        .game-header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .score {
            font-size: 1.2rem;
            background: rgba(255,255,255,0.2);
            padding: 10px 20px;
            border-radius: 25px;
            backdrop-filter: blur(10px);
        }

        .game-container {
            position: relative;
            width: min(600px, 95vw);
            height: min(700px, 85vh);
            max-width: 600px;
            max-height: 700px;
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255,255,255,0.2);
            overflow: hidden;
        }

        #gameCanvas {
            display: block;
            border-radius: 18px;
            cursor: crosshair;
            width: 100%;
            height: 100%;
        }

        .controls {
            margin-top: 20px;
            text-align: center;
        }

        .btn {
            background: #4ecdc4;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            font-size: 1rem;
            cursor: pointer;
            margin: 0 10px;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .btn:hover {
            background: #45b7aa;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            display: none;
            z-index: 1000;
        }

        .joystick-container {
            position: absolute;
            bottom: min(20px, 3vh);
            right: min(20px, 3vw);
            width: min(120px, 15vw);
            height: min(120px, 15vw);
            min-width: 80px;
            min-height: 80px;
            max-width: 140px;
            max-height: 140px;
            background: rgba(255,255,255,0.1);
            border-radius: 50%;
            border: 3px solid rgba(255,255,255,0.3);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 100;
        }

        .joystick-container:hover {
            background: rgba(255,255,255,0.15);
            border-color: rgba(255,255,255,0.5);
            transform: scale(1.05);
        }

        .joystick-knob {
            width: min(50px, 6vw);
            height: min(50px, 6vw);
            min-width: 30px;
            min-height: 30px;
            max-width: 60px;
            max-height: 60px;
            background: linear-gradient(135deg, #4ecdc4, #45b7d1);
            border-radius: 50%;
            border: 3px solid white;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3), 0 0 20px rgba(78,205,196,0.4);
            transition: all 0.2s ease;
            position: relative;
        }

        .joystick-knob::before {
            content: '';
            position: absolute;
            top: 3px;
            left: 3px;
            width: min(15px, 25%);
            height: min(15px, 25%);
            background: rgba(255,255,255,0.8);
            border-radius: 50%;
        }

        @media (max-width: 768px) {
            .game-header h1 {
                font-size: min(2rem, 8vw);
            }
            
            .score {
                font-size: min(1.2rem, 5vw);
                padding: min(10px, 2vw) min(20px, 4vw);
            }
            
            .btn {
                padding: min(12px, 3vw) min(24px, 5vw);
                font-size: min(1rem, 4vw);
                margin: 0 min(10px, 2vw);
            }
        }

        @media (max-height: 600px) {
            .game-header {
                margin-bottom: 10px;
            }
            
            .game-header h1 {
                font-size: 1.8rem;
                margin-bottom: 5px;
            }
            
            .controls {
                margin-top: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="game-header">
        <h1>ðŸŽ¯ Bubble Shooter</h1>
        <div class="score">Score: <span id="score">0</span></div>
    </div>

    <div class="game-container">
        <canvas id="gameCanvas" width="600" height="700"></canvas>
        
        <div class="joystick-container" id="joystick">
            <div class="joystick-knob" id="joystickKnob"></div>
        </div>
        
        <div class="game-over" id="gameOver">
            <h2>ðŸŽ‰ Game Over!</h2>
            <p>Final Score: <span id="finalScore">0</span></p>
            <button class="btn" onclick="startNewGame()">Play Again</button>
        </div>
    </div>

    <div class="controls">
        <button class="btn" onclick="startNewGame()">New Game</button>
        <button class="btn" onclick="togglePause()">Pause</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Responsive canvas setup
        let canvasWidth = 600;
        let canvasHeight = 700;
        let scaleFactor = 1;
        
        function resizeCanvas() {
            const container = document.querySelector('.game-container');
            const containerRect = container.getBoundingClientRect();
            
            canvasWidth = containerRect.width;
            canvasHeight = containerRect.height;
            
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            
            scaleFactor = Math.min(canvasWidth / 600, canvasHeight / 700);
            
            // Update game constants based on scale
            BUBBLE_RADIUS = 20 * scaleFactor;
            SHOOTER_X = canvasWidth / 2;
            SHOOTER_Y = canvasHeight - (50 * scaleFactor);
        }
        
        let gameState = {
            score: 0,
            bubbles: [],
            currentBubble: null,
            shooterAngle: -Math.PI / 2,
            gameRunning: true,
            paused: false,
            particles: [],
            mouseX: canvasWidth / 2,
            mouseY: canvasHeight - 100,
            joystickActive: false,
            joystickCenter: { x: 0, y: 0 },
            isDragging: false,
            lastTouchTime: 0
        };

        const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57', '#ff9ff3', '#54a0ff'];
        let BUBBLE_RADIUS = 20;
        const ROWS = 8;
        let COLS = 15;
        let SHOOTER_X = canvasWidth / 2;
        let SHOOTER_Y = canvasHeight - 50;

        class Bubble {
            constructor(x, y, color, row = -1, col = -1) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.radius = BUBBLE_RADIUS;
                this.row = row;
                this.col = col;
                this.vx = 0;
                this.vy = 0;
                this.moving = false;
                this.scale = 0;
                this.targetScale = 1;
                this.rotation = 0;
                this.pulsePhase = Math.random() * Math.PI * 2;
                this.sparkles = [];
                this.isPopping = false;
                this.popAnimation = 0;
                this.glowIntensity = 0;
                
                // Initialize sparkles
                for (let i = 0; i < 3; i++) {
                    this.sparkles.push({
                        angle: Math.random() * Math.PI * 2,
                        distance: Math.random() * 15 + 10,
                        size: Math.random() * 2 + 1,
                        speed: Math.random() * 0.02 + 0.01
                    });
                }
            }

            draw() {
                // Update animations
                this.scale += (this.targetScale - this.scale) * 0.15;
                this.rotation += 0.01;
                this.pulsePhase += 0.05;
                
                if (this.isPopping) {
                    this.popAnimation += 0.2;
                    this.scale = 1 + Math.sin(this.popAnimation) * 0.5;
                    this.glowIntensity = Math.max(0, 1 - this.popAnimation / 3);
                    if (this.popAnimation > 3) return false;
                }
                
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                ctx.scale(this.scale, this.scale);
                
                // Glow effect
                if (this.glowIntensity > 0 || this.moving) {
                    const glowRadius = this.radius + 10;
                    const gradient = ctx.createRadialGradient(0, 0, this.radius, 0, 0, glowRadius);
                    gradient.addColorStop(0, this.color + '00');
                    gradient.addColorStop(0.7, this.color + Math.floor((this.glowIntensity || 0.5) * 100 + 50).toString(16));
                    gradient.addColorStop(1, this.color + '00');
                    
                    ctx.beginPath();
                    ctx.arc(0, 0, glowRadius, 0, Math.PI * 2);
                    ctx.fillStyle = gradient;
                    ctx.fill();
                }
                
                // Main bubble with gradient
                const bubbleGradient = ctx.createRadialGradient(-5, -5, 0, 0, 0, this.radius);
                bubbleGradient.addColorStop(0, this.lightenColor(this.color, 40));
                bubbleGradient.addColorStop(0.7, this.color);
                bubbleGradient.addColorStop(1, this.darkenColor(this.color, 20));
                
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = bubbleGradient;
                ctx.fill();
                
                // Animated border
                const borderPulse = Math.sin(this.pulsePhase) * 0.3 + 0.7;
                ctx.strokeStyle = `rgba(255,255,255,${borderPulse})`;
                ctx.lineWidth = 3;
                ctx.stroke();
                
                // Multiple shine effects
                ctx.beginPath();
                ctx.arc(-6, -6, this.radius * 0.35, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255,255,255,0.8)';
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(-3, -8, this.radius * 0.15, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255,255,255,0.9)';
                ctx.fill();
                
                // Sparkle effects
                this.sparkles.forEach(sparkle => {
                    sparkle.angle += sparkle.speed;
                    const sparkleX = Math.cos(sparkle.angle) * sparkle.distance;
                    const sparkleY = Math.sin(sparkle.angle) * sparkle.distance;
                    
                    ctx.beginPath();
                    ctx.arc(sparkleX, sparkleY, sparkle.size, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255,255,255,${0.6 + Math.sin(sparkle.angle * 3) * 0.4})`;
                    ctx.fill();
                });
                
                ctx.restore();
                return true;
            }

            update() {
                if (this.moving) {
                    this.x += this.vx;
                    this.y += this.vy;
                    this.glowIntensity = 0.8;
                    
                    // Bounce off walls
                    if (this.x <= this.radius || this.x >= canvas.width - this.radius) {
                        this.vx = -this.vx;
                        this.x = Math.max(this.radius, Math.min(canvas.width - this.radius, this.x));
                        this.targetScale = 1.2;
                        setTimeout(() => this.targetScale = 1, 200);
                    }
                } else {
                    this.glowIntensity *= 0.95;
                }
                
                // Gentle floating animation
                if (!this.moving && !this.isPopping) {
                    this.y += Math.sin(Date.now() * 0.001 + this.x * 0.01) * 0.2;
                }
            }

            startPopAnimation() {
                this.isPopping = true;
                this.popAnimation = 0;
            }

            lightenColor(color, percent) {
                const num = parseInt(color.replace("#", ""), 16);
                const amt = Math.round(2.55 * percent);
                const R = (num >> 16) + amt;
                const G = (num >> 8 & 0x00FF) + amt;
                const B = (num & 0x0000FF) + amt;
                return "#" + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
                    (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
                    (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
            }

            darkenColor(color, percent) {
                const num = parseInt(color.replace("#", ""), 16);
                const amt = Math.round(2.55 * percent);
                const R = (num >> 16) - amt;
                const G = (num >> 8 & 0x00FF) - amt;
                const B = (num & 0x0000FF) - amt;
                return "#" + (0x1000000 + (R > 255 ? 255 : R < 0 ? 0 : R) * 0x10000 +
                    (G > 255 ? 255 : G < 0 ? 0 : G) * 0x100 +
                    (B > 255 ? 255 : B < 0 ? 0 : B)).toString(16).slice(1);
            }

            distanceTo(other) {
                return Math.sqrt((this.x - other.x) ** 2 + (this.y - other.y) ** 2);
            }
        }

        function initializeGrid() {
            gameState.bubbles = [];
            COLS = Math.floor(canvasWidth / (BUBBLE_RADIUS * 2)) - 1;
            
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    if (row < 5) {
                        const offsetX = (row % 2) * BUBBLE_RADIUS;
                        const x = col * (BUBBLE_RADIUS * 2) + BUBBLE_RADIUS + offsetX;
                        const y = row * (BUBBLE_RADIUS * 1.7) + BUBBLE_RADIUS;
                        
                        if (x < canvasWidth - BUBBLE_RADIUS) {
                            const color = colors[Math.floor(Math.random() * colors.length)];
                            const bubble = new Bubble(x, y, color, row, col);
                            
                            setTimeout(() => {
                                bubble.targetScale = 1;
                            }, (row * COLS + col) * 30);
                            
                            gameState.bubbles.push(bubble);
                        }
                    }
                }
            }
        }

        function createNewBubble() {
            const color = colors[Math.floor(Math.random() * colors.length)];
            const bubble = new Bubble(SHOOTER_X, SHOOTER_Y, color);
            bubble.targetScale = 1;
            return bubble;
        }

        function drawShooter() {
            // Draw shooter base
            ctx.save();
            ctx.translate(SHOOTER_X, SHOOTER_Y);
            
            // Shooter glow
            const glowGradient = ctx.createRadialGradient(0, 0, 25, 0, 0, 40);
            glowGradient.addColorStop(0, gameState.currentBubble ? gameState.currentBubble.color + '80' : '#ff6b6b80');
            glowGradient.addColorStop(1, gameState.currentBubble ? gameState.currentBubble.color + '00' : '#ff6b6b00');
            
            ctx.beginPath();
            ctx.arc(0, 0, 40, 0, Math.PI * 2);
            ctx.fillStyle = glowGradient;
            ctx.fill();
            
            // Shooter body
            const shooterGradient = ctx.createRadialGradient(-5, -5, 0, 0, 0, 25);
            shooterGradient.addColorStop(0, '#ffffff');
            shooterGradient.addColorStop(0.3, gameState.currentBubble ? gameState.currentBubble.color : '#ff6b6b');
            shooterGradient.addColorStop(1, gameState.currentBubble ? gameState.currentBubble.color : '#ff6b6b');
            
            ctx.beginPath();
            ctx.arc(0, 0, 25, 0, Math.PI * 2);
            ctx.fillStyle = shooterGradient;
            ctx.fill();
            
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 3;
            ctx.stroke();
            
            ctx.restore();
        }

        function drawAimingLine() {
            if (!gameState.currentBubble || gameState.currentBubble.moving || gameState.paused) return;
            
            const startX = SHOOTER_X;
            const startY = SHOOTER_Y;
            
            // Calculate trajectory with bounces
            let currentX = startX;
            let currentY = startY;
            let currentVx = Math.cos(gameState.shooterAngle) * 8;
            let currentVy = Math.sin(gameState.shooterAngle) * 8;
            
            const trajectoryPoints = [];
            trajectoryPoints.push({x: currentX, y: currentY});
            
            for (let i = 0; i < 100; i++) {
                currentX += currentVx;
                currentY += currentVy;
                
                // Wall bounces
                if (currentX <= BUBBLE_RADIUS || currentX >= canvas.width - BUBBLE_RADIUS) {
                    currentVx = -currentVx;
                    currentX = Math.max(BUBBLE_RADIUS, Math.min(canvas.width - BUBBLE_RADIUS, currentX));
                }
                
                // Check collision with existing bubbles
                let hitBubble = false;
                for (let bubble of gameState.bubbles) {
                    if (Math.sqrt((currentX - bubble.x) ** 2 + (currentY - bubble.y) ** 2) < BUBBLE_RADIUS * 2) {
                        hitBubble = true;
                        break;
                    }
                }
                
                if (hitBubble || currentY <= BUBBLE_RADIUS) {
                    break;
                }
                
                trajectoryPoints.push({x: currentX, y: currentY});
            }
            
            // Draw trajectory line
            if (trajectoryPoints.length > 1) {
                ctx.beginPath();
                ctx.moveTo(trajectoryPoints[0].x, trajectoryPoints[0].y);
                
                for (let i = 1; i < trajectoryPoints.length; i++) {
                    ctx.lineTo(trajectoryPoints[i].x, trajectoryPoints[i].y);
                }
                
                const gradient = ctx.createLinearGradient(startX, startY, trajectoryPoints[trajectoryPoints.length-1].x, trajectoryPoints[trajectoryPoints.length-1].y);
                gradient.addColorStop(0, 'rgba(255,255,255,0.9)');
                gradient.addColorStop(0.5, 'rgba(255,255,255,0.6)');
                gradient.addColorStop(1, 'rgba(255,255,255,0.2)');
                
                ctx.strokeStyle = gradient;
                ctx.lineWidth = 4;
                ctx.lineCap = 'round';
                ctx.setLineDash([15, 10]);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            // Draw aiming dots
            for (let i = 0; i < trajectoryPoints.length; i += 5) {
                const point = trajectoryPoints[i];
                const alpha = 0.8 - (i / trajectoryPoints.length) * 0.6;
                
                ctx.beginPath();
                ctx.arc(point.x, point.y, 3, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255,255,255,${alpha})`;
                ctx.fill();
            }
        }

        function findConnectedBubbles(bubble, visited = new Set()) {
            const connected = [bubble];
            visited.add(bubble);
            
            gameState.bubbles.forEach(other => {
                if (!visited.has(other) && 
                    other.color === bubble.color && 
                    bubble.distanceTo(other) < BUBBLE_RADIUS * 2.2) {
                    connected.push(...findConnectedBubbles(other, visited));
                }
            });
            
            return connected;
        }

        function createParticleExplosion(x, y, color) {
            for (let i = 0; i < 12; i++) {
                const particle = {
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 12,
                    vy: (Math.random() - 0.5) * 12,
                    color: color,
                    life: 1,
                    decay: 0.015,
                    size: Math.random() * 5 + 2
                };
                gameState.particles.push(particle);
            }
        }

        function removeBubbles(bubblesToRemove) {
            bubblesToRemove.forEach((bubble, index) => {
                setTimeout(() => {
                    bubble.startPopAnimation();
                    createParticleExplosion(bubble.x, bubble.y, bubble.color);
                }, index * 50);
            });
            
            setTimeout(() => {
                bubblesToRemove.forEach(bubble => {
                    const index = gameState.bubbles.indexOf(bubble);
                    if (index > -1) {
                        gameState.bubbles.splice(index, 1);
                        gameState.score += 10;
                    }
                });
                
                // Remove floating bubbles
                const connectedToTop = new Set();
                gameState.bubbles.forEach(bubble => {
                    if (bubble.row === 0) {
                        findFloatingBubbles(bubble, connectedToTop);
                    }
                });
                
                const floating = gameState.bubbles.filter(bubble => !connectedToTop.has(bubble));
                floating.forEach((bubble, index) => {
                    setTimeout(() => {
                        bubble.startPopAnimation();
                        createParticleExplosion(bubble.x, bubble.y, bubble.color);
                        setTimeout(() => {
                            const bubbleIndex = gameState.bubbles.indexOf(bubble);
                            if (bubbleIndex > -1) {
                                gameState.bubbles.splice(bubbleIndex, 1);
                                gameState.score += 5;
                            }
                        }, 300);
                    }, index * 80);
                });
            }, 400);
        }

        function findFloatingBubbles(bubble, connected) {
            if (connected.has(bubble)) return;
            connected.add(bubble);
            
            gameState.bubbles.forEach(other => {
                if (!connected.has(other) && bubble.distanceTo(other) < BUBBLE_RADIUS * 2.2) {
                    findFloatingBubbles(other, connected);
                }
            });
        }

        function checkCollision() {
            if (!gameState.currentBubble || !gameState.currentBubble.moving) return;
            
            // Check collision with existing bubbles
            for (let bubble of gameState.bubbles) {
                if (gameState.currentBubble.distanceTo(bubble) < BUBBLE_RADIUS * 2) {
                    gameState.currentBubble.moving = false;
                    gameState.currentBubble.vx = 0;
                    gameState.currentBubble.vy = 0;
                    
                    snapToGrid(gameState.currentBubble, bubble);
                    gameState.bubbles.push(gameState.currentBubble);
                    
                    const connected = findConnectedBubbles(gameState.currentBubble);
                    if (connected.length >= 3) {
                        removeBubbles(connected);
                    }
                    
                    gameState.currentBubble = createNewBubble();
                    return;
                }
            }
            
            // Check collision with top
            if (gameState.currentBubble.y <= BUBBLE_RADIUS) {
                gameState.currentBubble.moving = false;
                gameState.currentBubble.y = BUBBLE_RADIUS;
                gameState.bubbles.push(gameState.currentBubble);
                gameState.currentBubble = createNewBubble();
            }
        }

        function snapToGrid(newBubble, nearBubble) {
            const positions = [
                { x: nearBubble.x - BUBBLE_RADIUS * 2, y: nearBubble.y },
                { x: nearBubble.x + BUBBLE_RADIUS * 2, y: nearBubble.y },
                { x: nearBubble.x - BUBBLE_RADIUS, y: nearBubble.y - BUBBLE_RADIUS * 1.7 },
                { x: nearBubble.x + BUBBLE_RADIUS, y: nearBubble.y - BUBBLE_RADIUS * 1.7 },
                { x: nearBubble.x, y: nearBubble.y - BUBBLE_RADIUS * 2 }
            ];
            
            for (let pos of positions) {
                let valid = true;
                for (let bubble of gameState.bubbles) {
                    if (Math.sqrt((pos.x - bubble.x) ** 2 + (pos.y - bubble.y) ** 2) < BUBBLE_RADIUS * 1.8) {
                        valid = false;
                        break;
                    }
                }
                if (valid && pos.y > 0 && pos.x > BUBBLE_RADIUS && pos.x < canvas.width - BUBBLE_RADIUS) {
                    newBubble.x = pos.x;
                    newBubble.y = pos.y;
                    return;
                }
            }
        }

        function shoot() {
            if (!gameState.currentBubble || gameState.currentBubble.moving || gameState.paused) return;
            
            const speed = 8;
            gameState.currentBubble.vx = Math.cos(gameState.shooterAngle) * speed;
            gameState.currentBubble.vy = Math.sin(gameState.shooterAngle) * speed;
            gameState.currentBubble.moving = true;
        }

        function gameLoop() {
            if (!gameState.gameRunning) return;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (!gameState.paused) {
                // Update bubbles
                gameState.bubbles = gameState.bubbles.filter(bubble => bubble.draw());
                gameState.bubbles.forEach(bubble => bubble.update());
                
                if (gameState.currentBubble) {
                    gameState.currentBubble.update();
                    checkCollision();
                }
                
                // Check win condition
                if (gameState.bubbles.length === 0) {
                    gameState.score += 1000;
                    setTimeout(() => initializeGrid(), 1000);
                }
                
                // Check lose condition
                const lowestBubble = Math.max(...gameState.bubbles.map(b => b.y), 0);
                if (lowestBubble > canvas.height - 120) {
                    endGame();
                    return;
                }
            }
            
            // Update particles
            gameState.particles = gameState.particles.filter(particle => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.vy += 0.3;
                particle.life -= particle.decay;
                
                if (particle.life > 0) {
                    ctx.save();
                    ctx.globalAlpha = particle.life;
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    ctx.fillStyle = particle.color;
                    ctx.fill();
                    ctx.restore();
                    return true;
                }
                return false;
            });
            
            // Draw everything
            gameState.bubbles.forEach(bubble => bubble.draw());
            
            if (gameState.currentBubble) {
                gameState.currentBubble.draw();
            }
            
            drawAimingLine();
            drawShooter();
            
            document.getElementById('score').textContent = gameState.score;
            
            requestAnimationFrame(gameLoop);
        }

        function endGame() {
            gameState.gameRunning = false;
            document.getElementById('finalScore').textContent = gameState.score;
            document.getElementById('gameOver').style.display = 'block';
        }

        function startNewGame() {
            gameState = {
                score: 0,
                bubbles: [],
                currentBubble: null,
                shooterAngle: -Math.PI / 2,
                gameRunning: true,
                paused: false,
                particles: [],
                mouseX: canvasWidth / 2,
                mouseY: canvasHeight - 100,
                joystickActive: false,
                joystickCenter: { x: 0, y: 0 },
                isDragging: false,
                lastTouchTime: 0
            };
            
            document.getElementById('gameOver').style.display = 'none';
            initializeGrid();
            gameState.currentBubble = createNewBubble();
            if (gameState.gameRunning) {
                gameLoop();
            }
        }

        function togglePause() {
            gameState.paused = !gameState.paused;
        }

        // Enhanced aiming system
        function updateAiming(clientX, clientY) {
            if (gameState.paused || gameState.joystickActive) return;
            
            const rect = canvas.getBoundingClientRect();
            gameState.mouseX = (clientX - rect.left) * (canvasWidth / rect.width);
            gameState.mouseY = (clientY - rect.top) * (canvasHeight / rect.height);
            
            gameState.shooterAngle = Math.atan2(
                gameState.mouseY - SHOOTER_Y,
                gameState.mouseX - SHOOTER_X
            );
            
            // Limit shooting angle
            if (gameState.shooterAngle > -Math.PI * 0.1) gameState.shooterAngle = -Math.PI * 0.1;
            if (gameState.shooterAngle < -Math.PI * 0.9) gameState.shooterAngle = -Math.PI * 0.9;
        }

        // Mouse events
        canvas.addEventListener('mousemove', (e) => {
            updateAiming(e.clientX, e.clientY);
        });

        canvas.addEventListener('mousedown', (e) => {
            gameState.isDragging = true;
            updateAiming(e.clientX, e.clientY);
        });

        canvas.addEventListener('mouseup', () => {
            if (gameState.isDragging) {
                gameState.isDragging = false;
                shoot();
            }
        });

        canvas.addEventListener('click', (e) => {
            if (!gameState.isDragging) {
                shoot();
            }
        });

        // Enhanced touch support
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const currentTime = Date.now();
            const touch = e.touches[0];
            
            gameState.isDragging = true;
            gameState.lastTouchTime = currentTime;
            updateAiming(touch.clientX, touch.clientY);
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (gameState.isDragging && e.touches.length > 0) {
                const touch = e.touches[0];
                updateAiming(touch.clientX, touch.clientY);
            }
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            const currentTime = Date.now();
            
            if (gameState.isDragging) {
                gameState.isDragging = false;
                
                // Shoot after a brief delay or immediate tap
                const touchDuration = currentTime - gameState.lastTouchTime;
                if (touchDuration < 200) {
                    // Quick tap - shoot immediately
                    setTimeout(shoot, 50);
                } else {
                    // Drag and release - shoot
                    shoot();
                }
            }
        });

        // Joystick functionality
        const joystick = document.getElementById('joystick');
        const joystickKnob = document.getElementById('joystickKnob');

        function initJoystick() {
            const rect = joystick.getBoundingClientRect();
            gameState.joystickCenter = {
                x: rect.left + rect.width / 2,
                y: rect.top + rect.height / 2
            };
        }

        function updateJoystickPosition(clientX, clientY) {
            const rect = joystick.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            const deltaX = clientX - centerX;
            const deltaY = clientY - centerY;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            const maxDistance = Math.min(rect.width, rect.height) * 0.3; // Responsive max distance
            
            let knobX = deltaX;
            let knobY = deltaY;
            
            if (distance > maxDistance) {
                knobX = (deltaX / distance) * maxDistance;
                knobY = (deltaY / distance) * maxDistance;
            }
            
            joystickKnob.style.transform = `translate(${knobX}px, ${knobY}px)`;
            
            // Update shooting angle based on joystick position
            const deadZone = Math.min(rect.width, rect.height) * 0.05;
            if (distance > deadZone) {
                gameState.shooterAngle = Math.atan2(knobY, knobX);
                
                // Limit shooting angle
                if (gameState.shooterAngle > -Math.PI * 0.1) gameState.shooterAngle = -Math.PI * 0.1;
                if (gameState.shooterAngle < -Math.PI * 0.9) gameState.shooterAngle = -Math.PI * 0.9;
            }
        }

        function resetJoystick() {
            joystickKnob.style.transform = 'translate(0px, 0px)';
            gameState.joystickActive = false;
        }

        // Joystick mouse events
        joystick.addEventListener('mousedown', (e) => {
            e.preventDefault();
            gameState.joystickActive = true;
            initJoystick();
            updateJoystickPosition(e.clientX, e.clientY);
        });

        document.addEventListener('mousemove', (e) => {
            if (gameState.joystickActive) {
                updateJoystickPosition(e.clientX, e.clientY);
            }
        });

        document.addEventListener('mouseup', () => {
            if (gameState.joystickActive) {
                resetJoystick();
            }
        });

        // Joystick touch events
        joystick.addEventListener('touchstart', (e) => {
            e.preventDefault();
            gameState.joystickActive = true;
            initJoystick();
            const touch = e.touches[0];
            updateJoystickPosition(touch.clientX, touch.clientY);
        });

        document.addEventListener('touchmove', (e) => {
            if (gameState.joystickActive && e.touches.length > 0) {
                e.preventDefault();
                const touch = e.touches[0];
                updateJoystickPosition(touch.clientX, touch.clientY);
            }
        });

        document.addEventListener('touchend', () => {
            if (gameState.joystickActive) {
                resetJoystick();
            }
        });

        // Joystick click to shoot
        joystick.addEventListener('click', (e) => {
            e.stopPropagation();
            shoot();
        });

        // Initialize and handle window resize
        function handleResize() {
            resizeCanvas();
            initJoystick();
            
            // Reposition existing bubbles proportionally
            if (gameState.bubbles.length > 0) {
                gameState.bubbles.forEach(bubble => {
                    bubble.x = bubble.x * scaleFactor;
                    bubble.y = bubble.y * scaleFactor;
                    bubble.radius = BUBBLE_RADIUS;
                });
            }
            
            if (gameState.currentBubble) {
                gameState.currentBubble.x = SHOOTER_X;
                gameState.currentBubble.y = SHOOTER_Y;
                gameState.currentBubble.radius = BUBBLE_RADIUS;
            }
        }

        window.addEventListener('resize', handleResize);
        window.addEventListener('orientationchange', () => {
            setTimeout(handleResize, 100);
        });

        // Initialize everything
        setTimeout(() => {
            resizeCanvas();
            initJoystick();
            startNewGame();
        }, 100);
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'96c10c7a92417e53',t:'MTc1NDY3NzQ0Ny4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>